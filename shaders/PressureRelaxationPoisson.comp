#version 450

#include "PushConstants.glsl"
#include "PoissonFilter.glsl"

layout(local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0, r16f) uniform image2D divergence_texture;
layout(set = 0, binding = 1, r16f) uniform image2D pressure_texture;
layout(set = 0, binding = 2, rgba32f) uniform image2D temp_texture;
layout(set = 0, binding = 3, rgba32f) uniform image2D temp_texture1;
layout(set = 0, binding = 4) uniform sampler2D obstacle_mask_texture;

#include "Commons.glsl"

const int num_ranks = 4;
const int ranks_per_texture = 4;
const bool use_second_texture = (num_ranks > ranks_per_texture);

const int kernel_size = INVERSE_Itr_7_Filter_Size;
float grid_spacing = max(1.0 / push_constants.texture_width, 1.0 / push_constants.texture_height);

// Function to mirror coordinates for boundary handling
ivec2 MirrorCoords(ivec2 coords, ivec2 texture_size, vec2 uv_coords)
{
    ivec2 mirrored_coords = coords;

    if (mirrored_coords.x < 0)
        mirrored_coords.x = -mirrored_coords.x;
    else if (mirrored_coords.x >= texture_size.x)
        mirrored_coords.x = 2 * (texture_size.x - 1) - mirrored_coords.x;

    if (mirrored_coords.y < 0)
        mirrored_coords.y = -mirrored_coords.y;
    else if (mirrored_coords.y >= texture_size.y)
        mirrored_coords.y = 2 * (texture_size.y - 1) - mirrored_coords.y;

    vec2 sample_uv = (vec2(mirrored_coords) + 0.5) / vec2(texture_size);
    if (IsObstacle(sample_uv))
    {
        vec2 normal = CalculateNormal(uv_coords);
        ivec2 reflection = mirrored_coords - 2 * ivec2(round(normal));
        reflection = clamp(reflection, ivec2(0), texture_size - 1);
        return reflection;
    }

    return mirrored_coords;
}

vec4 GetMaskedVector(vec4 input_texture, int count)
{
    return vec4(
        count > 0 ? input_texture.x : 0.0,
        count > 1 ? input_texture.y : 0.0,
        count > 2 ? input_texture.z : 0.0,
        count > 3 ? input_texture.w : 0.0
    );
}

void VerticalPass(ivec2 coords, ivec2 texture_size, vec2 uv_coords)
{
    vec2 direction = vec2(0.0, 1.0);
    float step_size = (kernel_size - 1) * 0.5;
    vec4 weighted_average_14 = vec4(0.0);  // Ranks 1-4
    vec4 weighted_average_58 = vec4(0.0);  // Ranks 5-8

    for (int i = 0; i < kernel_size; i++)
    {
        vec2 offset = direction * (float(i) - step_size);
        ivec2 neighbor_coords = coords + ivec2(offset);
        neighbor_coords = MirrorCoords(neighbor_coords, texture_size, uv_coords);
        float value = imageLoad(divergence_texture, neighbor_coords).r;

        weighted_average_14 += value * GetMaskedVector(
            INVERSE_Itr_7_R14_Filters[i], 
            min(num_ranks, ranks_per_texture)
        );

        if (use_second_texture)
        {
            weighted_average_58 += value * GetMaskedVector(
                INVERSE_Itr_7_R58_Filters[i], 
                num_ranks - ranks_per_texture
            );
        }
    }

    imageStore(temp_texture, coords, weighted_average_14);
    imageStore(temp_texture1, coords, weighted_average_58);
}

void HorizontalPass(ivec2 coords, ivec2 texture_size, vec2 uv_coords)
{
    vec2 direction = vec2(1.0, 0.0);
    float step_size = (kernel_size - 1) * 0.5;
    float final_pressure = 0.0;

    for (int i = 0; i < kernel_size; i++)
    {
        vec2 offset = direction * (float(i) - step_size);
        ivec2 neighbor_coords = coords + ivec2(offset);
        neighbor_coords = MirrorCoords(neighbor_coords, texture_size, uv_coords);
        
        vec4 intermediate_values_14 = imageLoad(temp_texture, neighbor_coords);
        
        final_pressure += dot(
            intermediate_values_14,
            -GetMaskedVector(INVERSE_Itr_7_R14_Filters[i], min(num_ranks, ranks_per_texture))
        );

        if (use_second_texture)
        {
            vec4 intermediate_values_58 = imageLoad(temp_texture1, neighbor_coords);
            final_pressure += dot(
                intermediate_values_58,
                -GetMaskedVector(INVERSE_Itr_7_R58_Filters[i], num_ranks - ranks_per_texture)
            );
        }
    }

    final_pressure *= (grid_spacing * grid_spacing);
    imageStore(pressure_texture, coords, vec4(final_pressure, 0.0, 0.0, 1.0));
}

void main()
{
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    if (pixel_coords.x >= push_constants.texture_width || pixel_coords.y >= push_constants.texture_height)
    {
        return;
    }

    vec2 pixel_size = vec2(1.0) / vec2(push_constants.texture_width, push_constants.texture_height);
    vec2 uv_coords = (vec2(pixel_coords) + 0.5) * pixel_size;
    ivec2 texture_size = ivec2(push_constants.texture_width, push_constants.texture_height);

    VerticalPass(pixel_coords, texture_size, uv_coords);

    memoryBarrier();
    barrier();

    HorizontalPass(pixel_coords, texture_size, uv_coords);
}
