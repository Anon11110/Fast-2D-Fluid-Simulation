
#version 450

layout(local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0) uniform sampler2D velocity_texture;
layout(set = 0, binding = 1, rg16f) uniform writeonly image2D advected_velocity_texture;

layout(push_constant) uniform PushConstants
{
    float current_time;
    float delta_time;
    int texture_width;
    int texture_height;
    float fluid_density;
    float vorticity_strength;
    bool reset_velocity;
} push_constants;

vec2 SampleVelocity(vec2 uv)
{
    vec2 velocity = texture(velocity_texture, uv).rg;
    vec2 wrap = vec2(1.0);

    if (uv.x < 0.0 || uv.x > 1.0)
    {
        wrap.x = -1.0;
    }
    if (uv.y < 0.0 || uv.y > 1.0)
    {
        wrap.y = -1.0;
    }

    return wrap * velocity;
}

void main()
{
    vec2 uv_scale = vec2(1.0) / vec2(push_constants.texture_width, push_constants.texture_height);
    float grid_scale = max(uv_scale.x, uv_scale.y);

    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    if (pixel_coords.x < 0 || pixel_coords.x >= push_constants.texture_width ||
        pixel_coords.y < 0 || pixel_coords.y >= push_constants.texture_height)
    {
        return;
    }

    vec2 texel_uv = (vec2(pixel_coords) + 0.5) * uv_scale;
    vec2 velocity = SampleVelocity(texel_uv);
    vec2 source_uv = texel_uv;
    vec2 source_velocity = velocity;

    const int advect_steps = 1;
    float delta_time = push_constants.delta_time / float(advect_steps);

    // Semi-Lagrangian advection
    for (int i = 0; i < advect_steps; i++)
    {
        source_uv -= source_velocity * uv_scale / grid_scale * delta_time;
        source_velocity = SampleVelocity(source_uv);

        if (source_uv.x <= 0.01 && source_uv.y > 0.45 && source_uv.y < 0.55)
        {
            source_velocity += vec2(10.0, 0.0) * push_constants.delta_time;
        }
    }

    // Sample velocities for vorticity computation
    vec2 velocity_ld = SampleVelocity(texel_uv - uv_scale);
    vec2 velocity_rd = SampleVelocity(texel_uv + vec2(uv_scale.x, -uv_scale.y));
    vec2 velocity_ru = SampleVelocity(texel_uv + uv_scale);
    vec2 velocity_lu = SampleVelocity(texel_uv + vec2(-uv_scale.x, uv_scale.y));

    vec2 velocity_ll = SampleVelocity(texel_uv + vec2(-2.0 * uv_scale.x, 0.0));
    vec2 velocity_rr = SampleVelocity(texel_uv + vec2(2.0 * uv_scale.x, 0.0));
    vec2 velocity_dd = SampleVelocity(texel_uv + vec2(0.0, -2.0 * uv_scale.y));
    vec2 velocity_uu = SampleVelocity(texel_uv + vec2(0.0, 2.0 * uv_scale.y));

    // Calculate curl at each direction
    float curl_left = velocity_lu.x - velocity_ld.x + velocity_ll.y - velocity.y;
    float curl_right = velocity_ru.x - velocity_rd.x + velocity.y - velocity_rr.y;
    float curl_down = velocity.x - velocity_dd.x + velocity_ld.y - velocity_rd.y;
    float curl_up = velocity_uu.x - velocity.x + velocity_lu.y - velocity_ru.y;

    vec2 vorticity_force = vec2(curl_down - curl_up, curl_right - curl_left);
    float vorticity_magnitude = length(vorticity_force);
    
    if (vorticity_magnitude > 0.00001)
    {
        vorticity_force *= grid_scale * push_constants.vorticity_strength / vorticity_magnitude;
    }
    else
    {
        vorticity_force = vec2(0.0);
    }

    vec2 advected_velocity = source_velocity + vorticity_force;

    if (push_constants.reset_velocity)
    {
        advected_velocity = vec2(0.0);
    }

    imageStore(advected_velocity_texture, pixel_coords, vec4(advected_velocity, 0.0, 1.0));
}
